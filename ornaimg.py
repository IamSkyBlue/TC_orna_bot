# encoding: utf-8
import os
import time
import re
import requests
from collections import OrderedDict

import discord
from discord.ext import commands, tasks

from dotenv import load_dotenv

import pygsheets

from google.cloud import vision

load_dotenv()
gc = pygsheets.authorize(service_account_env_var="GOOGLE_CREDENTIALS")

OrnaTCDB = gc.open("OrnaTCDB")
TCDBmainwks = OrnaTCDB[0]
imgporcesschannels = OrnaTCDB[1]
correctionsheet = OrnaTCDB[2]
specialitemsheet = OrnaTCDB[3]

visionclient = vision.ImageAnnotatorClient()

IMAGE_TYPE = ("jpeg", "png", "webp")
MATCH_WORD_TC = (
    "Ë°ÄÈáè:",
    "È≠îÂäõ:",
    "Ë≠∑Áõæ:",
    "Áâ©Êîª:",
    "Áâ©Èò≤:",
    "ÊïèÊç∑:",
    "È≠îÊîª:",
    "È≠îÈò≤:",
    "Êö¥Êìä:",
    "Ë¶ñÁ∑öÁØÑÂúç",
    "+Á∂ìÈ©óÂä†Êàê",
    "-Á∂ìÈ©óÂä†Êàê",
    "+ÈáëÂπ£Âä†Êàê",
    "-ÈáëÂπ£Âä†Êàê",
    "+Ê≠êÂπ£Âä†Êàê",
    "-Ê≠êÂπ£Âä†Êàê",
    "+Âπ∏ÈÅãÂä†Êàê",
    "-Âπ∏ÈÅãÂä†Êàê",
    "Ë∑üÈö®ËÄÖË°åÂãï",
    "+È≠îÂäõÁØÄËÉΩ",
    "-È≠îÂäõÁØÄËÉΩ",
    "Áï∞Â∏∏ÁãÄÊÖãÈò≤Ë≠∑",
    "Ë∑üÈö®ËÄÖÁ¥†Ë≥™",
)
MATCH_WORD_EN = (
    "HP:",
    "Mana:",
    "Ward:",
    "Att:",
    "Def:",
    "Dex:",
    "Mag:",
    "Res:",
    "Crit:",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
)


class Ornaimg(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        self.updatetime = time.time()
        self.imgporcesschannellist = imgporcesschannels.get_all_values(
            returnas="matrix",
            majdim="ROWS",
            include_tailing_empty=False,
            include_tailing_empty_rows=False,
        )[1::]

    @commands.command(
        name="subscribe",
        help="‰ΩøÁî®ÊñπÊ≥ï: ~subscribe | ‰Ωø‰∏≠ÊñáÊ©üÂô®‰∫∫Áõ£ËÅΩÊ≠§È†ªÈÅìÁöÑÂúñÁâá‰∏¶ÂòóË©¶Ëæ®Ë≠ò",
        brief="Êñ∞Â¢ûÈ†ªÈÅìËá≥Êà™ÂúñËá™ÂãïËæ®Ë≠òÂêçÂñÆ",
    )
    async def subscribe(self, ctx, *args):
        channelmatrix = imgporcesschannels.get_all_values(
            returnas="cell",
            majdim="ROWS",
            include_tailing_empty=False,
            include_tailing_empty_rows=False,
        )[1::]
        otherregistered = False
        for pair in channelmatrix:
            if (
                str(ctx.guild.id) == pair[0].value
                and str(ctx.channel.id) == pair[1].value
            ):
                await ctx.send("Êú¨È†ªÈÅìÂ∑≤Ë®ªÂÜäÈÅéÔºåÁÑ°È†àÂÜçÈÄ≤Ë°åË®ªÂÜä")
                return
            elif (
                str(ctx.guild.id) == pair[0].value
                and str(ctx.channel.id) != pair[1].value
            ):
                otherregistered = True
        imgporcesschannels.insert_rows(
            1, values=[str(ctx.guild.id), str(ctx.channel.id)]
        )
        if otherregistered:
            await ctx.send("ÊàêÂäüË®ªÂÜäÊú¨È†ªÈÅìÔºåÂÅµÊ∏¨Âà∞ÂÖ∂‰ªñÈ†ªÈÅì‰πüÊúâË®ªÂÜä\nËã•ÂÖ∂‰ªñÈ†ªÈÅìËΩâÁÇ∫ÂÖ∂‰ªñÁî®ÈÄîÔºåË®òÂæó‰ΩøÁî®~unsubscribeÈÄÄÂá∫Áõ£ËÅΩÈ†ªÈÅì")
        else:
            await ctx.send("ÊàêÂäüË®ªÂÜäÊú¨È†ªÈÅìÔºåË´ãÊ≥®ÊÑè10ÁßíÂæåÊ©üÂô®‰∫∫ÊâçÊúÉÈñãÂßãÁõ£ËÅΩÊú¨È†ªÈÅì")

    @commands.command(
        name="unsubscribe",
        help="‰ΩøÁî®ÊñπÊ≥ï: ~unsubscribe | ÁßªÈô§‰∏≠ÊñáÊ©üÂô®‰∫∫Â∞çÊ≠§È†ªÈÅìÁöÑÁõ£ËÅΩ",
        brief="Â∞áÊ≠§È†ªÈÅìÂæûÊà™ÂúñËá™ÂãïËæ®Ë≠òÂêçÂñÆÁßªÈô§",
    )
    async def unsubscribe(self, ctx, *args):
        channelmatrix = imgporcesschannels.get_all_values(
            returnas="cell",
            majdim="ROWS",
            include_tailing_empty=False,
            include_tailing_empty_rows=False,
        )
        for pair in channelmatrix:
            if (
                str(ctx.guild.id) == pair[0].value
                and str(ctx.channel.id) == pair[1].value
            ):
                imgporcesschannels.delete_rows(pair[0].row)
                await ctx.send("Â∑≤ÁßªÈô§Êú¨È†ªÈÅìÔºåÂèØ‰ΩøÁî®~subscribeÂÜçÊ¨°Ë®ÇÈñ±")
                return

    async def is_subscribe(self, msg) -> bool:
        if time.time() - self.updatetime > 10:
            self.imgporcesschannellist = imgporcesschannels.get_all_values(
                returnas="matrix",
                majdim="ROWS",
                include_tailing_empty=False,
                include_tailing_empty_rows=False,
            )[1::]
            self.updatetime = time.time()
        issubscribe = False
        for pair in self.imgporcesschannellist:
            if pair[0] == str(msg.guild.id) and pair[1] == str(msg.channel.id):
                issubscribe = True
        return issubscribe

    async def ornate_emoji(self, msg):
        if not await self.is_subscribe(msg):
            return
        for embed in msg.embeds:
            match = re.match(r"(Quality|ÂìÅË≥™): (\d+)%", embed.description)
            if match:
                quality = int(match.group(2))
                if 195 <= quality <= 200:
                    await msg.add_reaction("ü•≥")

    async def msg_process(self, msg):
        if not await self.is_subscribe(msg):
            return
        for att in msg.attachments:
            await msg.channel.trigger_typing()
            attname = att.content_type.split("/")[1]
            if attname in IMAGE_TYPE:
                await self.img_process(att, msg)

    async def img_process(self, att, msg):
        textlist = await self.img_text_detection_with_url(att.url)
        if not textlist:  # sometims google can't access the url
            file = await att.read()
            textlist = await self.img_text_detection_with_file(file)
        if not textlist:
            await msg.reply("ÁÑ°Ê≥ïËæ®Ë≠òÂúñÁâá‰∏≠ÁöÑÊñáÂ≠ó")
            return
        translated_strs = await self.img_find_strings(textlist, False)
        print("translated_strs: ", translated_strs)
        if translated_strs["untrans_itemnamestr"] == "":
            translated_strs = await self.img_find_strings(textlist, True)
        if translated_strs["untrans_itemnamestr"] == "":
            # if first try and second try all failed at this point
            # this mean the img is not game screenshot
            await msg.reply('ÁÑ°Ê≥ïËæ®Ë≠òÂúñÁâá‰∏≠ÁöÑÁâ©ÂìÅÂêçÁ®±ÔºåÊà™ÂúñË´ãÂãøÊìã‰ΩèÂ∑¶‰∏äËßíÁöÑ"ÂÑ≤ËóèÂÆ§"')
            return
        if translated_strs["israndom"]:
            await msg.reply("ornabotÁÑ°Ê≥ïËæ®Ë≠òÈö®Ê©üÁî¢ÁîüÁöÑÁâ©ÂìÅ")
            return
        if not translated_strs["istranslated"]:
            # the itemname need translation only if it is chinese
            correct_untrans_itemnamestr = await self.translate_correction(
                translated_strs["untrans_itemnamestr"]
            )
            itemnamestr = await self.img_text_translate(correct_untrans_itemnamestr)
        else:
            itemnamestr = ""
        levelstatstr = translated_strs["levelstr"] + translated_strs["statstr"]
        levelstatstr = levelstatstr.replace("\n", " ")
        levelstatstr = levelstatstr.replace("  ", " ")
        if not itemnamestr:
            # if img_text_translate return an empty string
            # this mean the name of the item can not be found in the ornaTCDB
            if translated_strs["istranslated"]:
                await msg.reply("Ëã±ÊñáÁâ©ÂìÅÂêçÁ®±: " + translated_strs["untrans_itemnamestr"])
                await msg.channel.send("Êú¨Ê©üÂô®‰∫∫ÈùûË®≠Ë®àÁµ¶ÂéüÊú¨Â∞±ÊòØËã±ÊñáÂêçÁ®±ÁöÑÁâ©ÂìÅÔºåË´ãÂ∞á‰ªãÈù¢Ë™ûË®ÄÂàáÊèõÊàêËã±ÊñáÁõ¥Êé•‰ΩøÁî®ornabot")
            else:
                await msg.reply(
                    "ÁÑ°Ê≥ïÂú®Ë≥áÊñôÂ∫´‰∏≠ÊâæÂà∞Áõ∏Á¨¶Áâ©ÂìÅ: " + translated_strs["untrans_itemnamestr"]
                )
                await msg.channel.send("ÂèØËÉΩÊòØÈö®Ê©üÁî¢ÁîüÁöÑÁâ©ÂìÅÊàñÊòØËæ®Ë≠òÈåØÂ≠óÔºåËã•ÊòØÈåØÂ≠óË´ãËÅØÁπ´ @SkyBlue#1688")
            await msg.channel.send(
                "Êï∏ÂÄºÂ≠ó‰∏≤: " + translated_strs["levelstr"] + translated_strs["statstr"]
            )
            return
        searchstr = "!assess " + itemnamestr + levelstatstr
        if await self.is_special_item(correct_untrans_itemnamestr):
            await msg.channel.send("ÂÅµÊ∏¨Âà∞ÊúâÈáçË§áÂêçÁ®±ÁöÑË£ùÂÇôÔºåË´ãÊü•Èñ±Orna Tawian‰∏≠ÊñáÊ©üÂô®‰∫∫È†ªÈÅìÈáòÈÅ∏Ôºå‰ª•Ê†°Ê≠£Â≠ó‰∏≤")
            await msg.reply(searchstr)
            return
        if translated_strs["hasadornment"]:
            await msg.channel.send("ÂÅµÊ∏¨Âà∞ÊúâÂØ∂Áü≥Èë≤ÂµåÔºåË´ãËá™Ë°åÊâ£Èô§ÂØ∂Áü≥ÊâÄÂ¢ûÂä†ÁöÑÊï∏ÂÄºÂæåÂÜçÂ∞áÂ≠ó‰∏≤Ë≤º‰∏ä")
            await msg.reply(searchstr)
            return
        stats = await self.use_api(
            itemnamestr, levelstatstr, translated_strs["levelstr"]
        )
        if stats == "404":
            await msg.reply("ÁÑ°Ê≥ïÊâæÂà∞Áõ∏Á¨¶Áâ©ÂìÅÔºåÂèØËÉΩÊòØorna guideÂ∞öÊú™Êñ∞Â¢ûÊ≠§Áâ©ÂìÅ‰πãÊï∏ÊìöÔºåË´ãÊîπÂ§©ÂÜçË©¶Ë©¶")
        elif stats:
            print(stats)
            embed = await self.json_to_embed(stats, correct_untrans_itemnamestr)
            await msg.reply(embed=embed)
        else:
            await msg.reply("ÁÑ°Ê≥ïÊ™¢Ê∏¨Âà∞Áõ∏Á¨¶ÁöÑÊï∏ÊìöÔºåÂèØËÉΩÊòØËæ®Ë≠òÈåØÂ≠óÊàñÊòØÊúâÂØ∂Áü≥Èë≤ÂµåÔºåË´ãË®ÇÊ≠£‰∏ãÂàóË®äÊÅØÂæåÂÜçË≤º‰∏ä")
            await msg.channel.send(searchstr)

    async def img_text_detection_with_url(self, url):
        image = vision.Image()
        image.source.image_uri = url
        response = visionclient.text_detection(image=image)
        if "text_annotations" not in response:
            print("Google API error:", response.error)  # logging
            return
        textlist = response.text_annotations[0].description.split("\n")
        return textlist

    async def img_text_detection_with_file(self, file):
        image = vision.Image(content=file)
        response = visionclient.text_detection(image=image)
        if "text_annotations" not in response:
            print("Google API error: ", response.error)  # logging
            return
        textlist = response.text_annotations[0].description.split("\n")
        return textlist

    async def img_find_strings(self, textlist, secondtry: bool):
        untrans_itemnamestr = ""
        levelstr = ""
        statstr = ""
        hasadornment = False
        israndom = False
        istranslated = False
        for textindex in range(0, len(textlist)):
            if textlist[textindex] == "Ë£ùÈ£æÂìÅ":
                hasadornment = True
                break
            if "Èö®Ê©üÁî¢Áîü" in textlist[textindex]:
                israndom = True
                break
            if textlist[textindex] == "ÂÑ≤ËóèÂÆ§":
                if (
                    secondtry
                ):  # main itemnamestr translation failed, try to use itemname on top left of the screen
                    untrans_itemnamestr = textlist[textindex - 1]
                else:
                    untrans_itemnamestr = textlist[textindex + 1]
                    indexcount = 0
                    while (
                        untrans_itemnamestr[0].isascii()
                        or len(untrans_itemnamestr) < 2
                        or untrans_itemnamestr.startswith(("Áî≥", "‰∏≠", "Âõû", "‚Ä¢"))
                    ):
                        if (
                            len(untrans_itemnamestr) > 10
                            and untrans_itemnamestr.isascii()
                            and not untrans_itemnamestr.startswith(
                                ("OO", "oo", "00", "*", "o0", "O0", "0", "‚Ä¢")
                            )
                        ):
                            # the item name is already english
                            istranslated = True
                            break
                        indexcount += 1
                        # sometimes Adornment slot or item img will being detect as texts
                        untrans_itemnamestr = textlist[textindex + 1 + indexcount]

            elif textlist[textindex].startswith("Á≠âÁ¥ö"):
                levelstr = textlist[textindex]
                levelstr = levelstr.replace(" ", "")
                levelstr = levelstr.replace("Á≠âÁ¥ö", "")
                levelstr = " (" + levelstr + ") "
            elif any(keyword in textlist[textindex] for keyword in MATCH_WORD_TC):
                statstr += textlist[textindex]
        if not levelstr:
            levelstr = " (1) "
        statstr = statstr.replace(" ", "")
        statstr = statstr.replace(",", "")  # 1,234 to 1234
        statstr = statstr.replace("‚Äî", "-")
        statstr = statstr.replace("o", "0")
        statstr = statstr.replace("O", "0")
        for TCstr, ENstr in zip(MATCH_WORD_TC, MATCH_WORD_EN):
            statstr = statstr.replace(TCstr, ENstr)

        return {
            "untrans_itemnamestr": untrans_itemnamestr,
            "levelstr": levelstr,
            "statstr": statstr,
            "hasadornment": hasadornment,
            "israndom": israndom,
            "istranslated": istranslated,
        }

    async def img_text_translate(self, untrans_itemnamestr):
        allmatchTitleRow = []
        data = TCDBmainwks.get_col(3, returnas="cell", include_tailing_empty=False)[2::]
        strindex = len(untrans_itemnamestr) - 1
        while strindex >= 0:  # loop search DB using [-1::],[-2::].....[0::]
            matchTitleRow = [
                title.row
                for title in data
                if title.value.lower() == untrans_itemnamestr[strindex::]
            ]
            allmatchTitleRow.extend(matchTitleRow)
            strindex -= 1
        if len(allmatchTitleRow) > 1:
            itemnamestrindex = allmatchTitleRow[-1]  # max len match string
        elif len(allmatchTitleRow) == 0:
            return
        else:
            itemnamestrindex = allmatchTitleRow[0]
        itemnamestr = TCDBmainwks.cell((itemnamestrindex, 2)).value
        return itemnamestr

    async def translate_correction(self, itemstring):
        correctionlist = correctionsheet.get_all_values(
            returnas="matrix",
            majdim="ROWS",
            include_tailing_empty=False,
            include_tailing_empty_rows=False,
        )[1::]
        for pair in correctionlist:
            itemstring = itemstring.replace(pair[0], pair[1])
        return itemstring

    async def is_special_item(self, correct_untrans_itemnamestr):
        specialitemlist = specialitemsheet.get_all_values(
            returnas="matrix",
            majdim="ROWS",
            include_tailing_empty=False,
            include_tailing_empty_rows=False,
        )[1::]
        for itemnamerow in specialitemlist:
            for itemname in itemnamerow:
                if itemname in correct_untrans_itemnamestr:
                    return True
        return False

    async def use_api(self, itemnamestr, statstr, levelstr):
        url = "https://orna.guide/api/v1/assess"
        data = {"name": itemnamestr}
        data["level"] = int(re.search(r"\((\d+)\)", levelstr).group(1))
        statslist = OrderedDict(
            [
                ("HP", "hp"),
                ("Mana", "mana"),
                ("Att", "attack"),
                ("Mag", "magic"),
                ("Def", "defense"),
                ("Res", "resistance"),
                ("Dex", "dexterity"),
                ("Ward", "ward"),
                ("Crit", "crit"),
            ]
        )
        regexstr = r" *[:Ôºö] *(-?\d+)"
        for key, value in statslist.items():
            number = re.search(key + regexstr, statstr)
            if number:
                data[value] = int(number.group(1))
        print("POSTdata: ", data)
        r = requests.post(url, json=data)
        if r.status_code == 200 and r.json()["quality"] != "0":
            return r.json()
        elif r.status_code == 404:
            return "404"
        else:
            return None

    async def json_to_embed(self, json, itemname):
        statsname = OrderedDict(
            [
                ("hp", "Ë°ÄÈáè"),
                ("mana", "È≠îÂäõ"),
                ("attack", "Áâ©Êîª"),
                ("magic", "È≠îÊîª"),
                ("defense", "Áâ©Èò≤"),
                ("resistance", "È≠îÈò≤"),
                ("dexterity", "ÊïèÊç∑"),
                ("ward", "Ë≠∑Áõæ"),
                ("crit", "Êö¥Êìä"),
            ]
        )
        title = itemname + " (" + json["name"] + ")"
        description = "ÂìÅË≥™: " + "{:.0%}\n".format(float(json["quality"]))
        details = [
            "{:<20}".format("Á≠âÁ¥ö 10:"),
            "{:<20}".format("Masterforged(Âå†Êîπ):"),
            "{:<20}".format("Demonforged(È≠îÊîπ):"),
            "{:<20}".format("Godforged(Á•ûË≥ú):"),
        ]
        for key, value in statsname.items():
            if key in json["stats"]:
                for i in range(len(details)):
                    details[i] += " {}:{:>4}".format(
                        value, json["stats"][key]["values"][i + 9]
                    )
        details = "\n".join(details)
        description += "```" + details + "```"
        quality = float(json["quality"]) * 100
        if quality < 100:
            color = 0xCC9700
        elif quality == 100:
            color = 0x7F7F7F
        elif 110 <= quality <= 119:
            color = 0x00CC00
        elif 120 <= quality <= 130:
            color = 0x00EEEE
        elif 140 <= quality <= 170:
            color = 0xDD00EE
        elif 170 <= quality <= 200:
            color = 0xEE0000
        return discord.Embed(title=title, description=description, color=color)

    @commands.Cog.listener()
    async def on_message(self, msg):
        if msg.attachments and not msg.author.bot:
            await self.msg_process(msg)
        elif msg.embeds:
            await self.ornate_emoji(msg)


def setup(bot):
    bot.add_cog(Ornaimg(bot))